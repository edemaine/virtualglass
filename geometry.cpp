
#include "geometry.h"
#include <iostream>
#include <fstream>
#ifndef MSVC
#include <unistd.h>
#endif

using std::vector;


Vertex :: Vertex(Point3D const &_position, Point3D const &_normal = make_vector(0.0f, 0.0f, 0.0f)) 
	: position(_position), normal(_normal) 
{
}

Triangle :: Triangle(uint32_t _v1 = -1U, uint32_t _v2 = -1U, uint32_t _v3 = -1U) : v1(_v1), v2(_v2), v3(_v3) 
{
}

Group :: Group(uint32_t _triangle_begin, uint32_t _triangle_size, uint32_t _vertex_begin, uint32_t _vertex_size,
	Color _color) : triangle_begin(_triangle_begin), triangle_size(_triangle_size), 
	vertex_begin(_vertex_begin), vertex_size(_vertex_size), color(_color)
{
}

void Geometry :: clear() 
{
	vertices.clear();
	triangles.clear();
	groups.clear();
}

bool Geometry :: valid() const {
	for (std::vector< Triangle >::const_iterator t = triangles.begin(); t != triangles.end(); ++t) {
		if (t->v1 >= vertices.size()) return false;
		if (t->v2 >= vertices.size()) return false;
		if (t->v3 >= vertices.size()) return false;
	}
	for (std::vector< Group >::const_iterator g = groups.begin(); g != groups.end(); ++g) {
		if (g->triangle_begin >= triangles.size()) return false;
		if (g->triangle_begin + g->triangle_size > triangles.size()) return false;
		if (g->vertex_begin >= vertices.size()) return false;
		if (g->vertex_begin + g->vertex_size > vertices.size()) return false;
	}
	return true;
}


//compute normals by using area-weighted normals of adjacent triangles.
//this may not be the correct approximation, but I just wanted some sort of hack
//to hold us until proper normal transforms could be written.
void Geometry::compute_normals_from_triangles() {
	assert(valid());
	vector< Vector3f > norms(vertices.size(), make_vector(0.0f, 0.0f, 0.0f));
	for (vector< Triangle >::const_iterator tri = triangles.begin(); tri != triangles.end(); ++tri) {
		Vector3f p1 = vertices[tri->v1].position;
		Vector3f p2 = vertices[tri->v2].position;
		Vector3f p3 = vertices[tri->v3].position;
		norms[tri->v1] += cross_product(p2 - p1, p3 - p1);
		norms[tri->v2] += cross_product(p3 - p2, p1 - p2);
		norms[tri->v3] += cross_product(p1 - p3, p2 - p3);
	}
	for (unsigned int v = 0; v < norms.size(); ++v) {
		if (norms[v] != make_vector(0.0f, 0.0f, 0.0f)) {
			vertices[v].normal = normalize(norms[v]);
		}
	}
}

void Geometry::save_ply_file(std::string const &filename) const {
	// let's follow the PLY standard as it's written in many places:
	// http://en.wikipedia.org/wiki/PLY_(file_format)
	// http://people.sc.fsu.edu/~jburkardt/data/ply/ply.html
	// http://paulbourke.net/dataformats/ply/
	// http://w3.impa.br/~diego/software/rply/
	//
	// we aren't using a library because we're just writing a simple PLY
	// file containing vertices and triangles
	std::ofstream file(filename.c_str());
	file << "ply\n";
	file << "format ascii 1.0\n";
	file << "comment Generated by VirtualGlass\n";
	file << "element vertex " << vertices.size() << "\n";
	file << "property float x\n";
	file << "property float y\n";
	file << "property float z\n";
	file << "property float nz\n";
	file << "property float ny\n";
	file << "property float nz\n";
	file << "element face " << triangles.size() << "\n";
	file << "property list uchar uint vertex_indices\n";
	file << "end_header\n";

	for (vector<Vertex>::const_iterator v = vertices.begin(); v != vertices.end(); ++v) {
		file << v->position.x << " "
			<< v->position.y << " "
			<< v->position.z << " " 
			<< v->normal.x << " "
			<< v->normal.y << " "
			<< v->normal.z << "\n";
	}

	for (vector<Triangle>::const_iterator t = triangles.begin(); t != triangles.end(); ++t) {
		file << "3 " << t->v1 << " " << t->v2 << " " << t->v3 << "\n"; 
	}
}

void Geometry::save_obj_file(std::string const &filename) const {
	std::ofstream file(filename.c_str());
	for (vector< Vertex >::const_iterator v = vertices.begin(); v != vertices.end(); ++v) {
		file << "vn " << v->normal.x << " "
			 << v->normal.y << " "
			 << v->normal.z << "\n";
		file << "v " << v->position.x << " "
			 << v->position.y << " "
			 << v->position.z << "\n";
	}
	for (vector< Triangle >::const_iterator t = triangles.begin(); t != triangles.end(); ++t) {
		file << "f " << (t->v1+1) << "//" << (t->v1+1) << " "
			 << (t->v2+1) << "//" << (t->v2+1) << " "
			 << (t->v3+1) << "//" << (t->v3+1) << "\n";
	}
}

void Geometry::save_raw_file(std::string const &filename) const {
	unlink(filename.c_str()); //remove file, if it exists
	{ //write to temp file:
		std::ofstream file((filename + ".temp").c_str(), std::ios::binary);

		file.write("RCG1", 4); //magic
		{ //count of groups:
			uint32_t size = groups.size();
			file.write(reinterpret_cast< const char * >(&size), 4);
		}

		for (vector< Group >::const_iterator g = groups.begin(); g != groups.end(); ++g) {
			vector< Vertex > group_verts;
			vector< uint32_t > vert_to_group(vertices.size(), -1U);
			assert(g->triangle_begin + g->triangle_size <= triangles.size());
			vector< Triangle > group_tris(triangles.begin() + g->triangle_begin, triangles.begin() + g->triangle_begin + g->triangle_size);
			assert(group_tris.size() == g->triangle_size);
			//Translate group_triangles indices:
			for (vector< Triangle >::iterator t = group_tris.begin(); t != group_tris.end(); ++t) {
				assert(t->v1 < vertices.size());
				assert(t->v2 < vertices.size());
				assert(t->v3 < vertices.size());
				if (vert_to_group[t->v1] >= group_verts.size()) {
					vert_to_group[t->v1] = group_verts.size();
					group_verts.push_back(vertices[t->v1]);
				}
				t->v1 = vert_to_group[t->v1];
				if (vert_to_group[t->v2] >= group_verts.size()) {
					vert_to_group[t->v2] = group_verts.size();
					group_verts.push_back(vertices[t->v2]);
				}
				t->v2 = vert_to_group[t->v2];
				if (vert_to_group[t->v3] >= group_verts.size()) {
					vert_to_group[t->v3] = group_verts.size();
					group_verts.push_back(vertices[t->v3]);
				}
				t->v3 = vert_to_group[t->v3];
				assert(t->v1 < group_verts.size());
				assert(t->v2 < group_verts.size());
				assert(t->v3 < group_verts.size());
			}
			file.write("COL0",4);
			{ //write group color:
				//Glass has diffuse skin coat over absorbing inner coat.
				Vector4f skin_color = g->color;
				//Filter-per-unit-length:
				Vector3f filter_after_unit = g->color.xyz;
				//intensify color:
				for (unsigned int i = 0; i < 3; ++i) {
					filter_after_unit.c[i] = powf(filter_after_unit.c[i], 20.0f);
				}
				file.write(reinterpret_cast< const char * >(&skin_color), sizeof(Vector4f));
				file.write(reinterpret_cast< const char * >(&filter_after_unit), sizeof(Vector3f));
			}

			file.write("VER0",4);
			//write group geometry:
			{ //count of verts:
				uint32_t size = group_verts.size();
				file.write(reinterpret_cast< const char * >(&size), 4);
			}
			//Verts should just be six floats:
			assert(sizeof(Vertex) == 4 * (3 + 3));
			//write verts:
			file.write(reinterpret_cast< const char *>(&(group_verts[0])), sizeof(Vertex) * group_verts.size());
			file.write("TRI0",4);
			{ //count of triangles:
				uint32_t size = group_tris.size();
				file.write(reinterpret_cast< const char * >(&size), 4);
			}
			//Triangles should be 3 32-bit unsigned integer inds:
			assert(sizeof(Triangle) == 4 * 3);
			//write triangles:
			file.write(reinterpret_cast< const char *>(&(group_tris[0])), sizeof(Triangle) * group_tris.size());
		}

	}
	//rename temp file to desired name:
	rename((filename + ".temp").c_str(), filename.c_str());
}
